# Schema Types Auto-Generation During Dev Mode

## Executive Summary

This document outlines a plan to automatically regenerate TypeScript type definitions from `.schema.tsx` files during development mode. The current manual approach requires running `npx tsx scripts/generate-schema-types.ts` every time a schema changes, which is error-prone and disruptive to the developer workflow.

---

## Current State Analysis

### How It Works Today

1. **Schema Files** (`.schema.tsx`): Define the structure of CMS components using a fluent builder API
   - Located in: `src/components/capsulo/<component>/<component>.schema.tsx`
   - Example: `src/components/capsulo/hero/hero.schema.tsx`

2. **Type Definition Files** (`.schema.d.ts`): Generated TypeScript interfaces
   - Located alongside schema files: `src/components/capsulo/<component>/<component>.schema.d.ts`
   - Auto-generated with comment: `// Auto-generated by scripts/generate-schema-types.ts`

3. **Manual Execution**: Developer must run:

   ```bash
   npx tsx scripts/generate-schema-types.ts
   ```

   Or target a specific file:

   ```bash
   npx tsx scripts/generate-schema-types.ts src/components/capsulo/hero/hero.schema.tsx
   ```

### Current Script Capabilities

The `scripts/generate-schema-types.ts` script:

- ✅ Supports targeting a single file via CLI argument
- ✅ Uses TypeScript AST parsing (via `ts` module) - robust approach
- ✅ Handles complex schema structures (Tabs, Grid, Repeater items)
- ✅ Updates corresponding `.astro` component files with type imports
- ✅ Uses shared CLI utilities (`scripts/lib/cli.js`) for consistent logging

### Files Currently Generated

| Source File | Generated File |
|-------------|----------------|
| `src/config/globals/globals.schema.tsx` | `src/config/globals/globals.schema.d.ts` |
| `src/components/capsulo/hero/hero.schema.tsx` | `src/components/capsulo/hero/hero.schema.d.ts` |
| `src/components/capsulo/footer/footer.schema.tsx` | `src/components/capsulo/footer/footer.schema.d.ts` |

---

## Proposed Solution

### Architecture Options

#### Option A: Vite Plugin (Recommended ⭐)

Create a new Vite plugin that watches `.schema.tsx` files and regenerates types automatically.

**Pros:**

- Integrates seamlessly with existing dev workflow
- Leverages existing file watching infrastructure (Vite/Chokidar)
- Follows the pattern already established by `vite-plugin-component-scanner.ts`
- Single source of truth for watch configuration
- HMR support possible (invalidate module when types change)

**Cons:**

- Adds complexity to the Vite configuration
- Type generation happens in-browser process (could slow down slightly)

#### Option B: Separate Watch Script

Run a parallel watcher process that monitors schema files.

**Pros:**

- Complete isolation from Vite
- Can be run independently

**Cons:**

- Requires separate `concurrently` entry in `package.json`
- Duplicates file watching logic
- Harder to coordinate with HMR

#### Option C: Extend Existing Component Scanner Plugin

Add schema type generation to `vite-plugin-component-scanner.ts`.

**Pros:**

- Single plugin handles all schema-related tasks
- Minimal changes to configuration

**Cons:**

- Conflates two distinct responsibilities
- Would make the plugin harder to maintain

### Recommended Approach: Option A (Vite Plugin)

Create `src/lib/vite-plugin-schema-types.ts` that:

1. Watches all `.schema.tsx` files during dev mode
2. Regenerates the corresponding `.d.ts` file on change
3. Optionally triggers HMR reload when types change
4. Reuses the parsing logic from `generate-schema-types.ts`

---

## Implementation Plan

### Phase 1: Refactor Core Logic into Shared Module

**Goal:** Extract the parsing and generation logic into a reusable module.

**Tasks:**

1. Create `scripts/lib/schema-parser.ts` with:
   - `parseSchemaFile(filePath: string): SchemaDefinition[]`
   - `generateDts(schemas: SchemaDefinition[]): string`
   - All type definitions (`FieldDefinition`, `SchemaDefinition`)

2. Refactor `scripts/generate-schema-types.ts` to import from `schema-parser.ts`

3. Ensure the module works with both ESM and Vite bundling

### Phase 2: Create Vite Plugin

**Goal:** Implement the watching plugin.

**File:** `src/lib/vite-plugin-schema-types.ts`

```typescript
import type { Plugin } from 'vite';
import path from 'node:path';
import fs from 'node:fs';
import { parseSchemaFile, generateDts } from '../../scripts/lib/schema-parser.js';

const SCHEMA_EXTENSION = '.schema.tsx';

export function schemaTypesPlugin(): Plugin {
    let isDev = false;
    let projectRoot = '';

    return {
        name: 'vite-plugin-schema-types',

        configResolved(config) {
            isDev = config.command === 'serve';
            projectRoot = config.root;
        },

        configureServer(server) {
            if (!isDev) return;

            const watcher = server.watcher;

            watcher.on('change', async (filePath) => {
                if (filePath.endsWith(SCHEMA_EXTENSION)) {
                    await regenerateTypes(filePath);
                }
            });

            watcher.on('add', async (filePath) => {
                if (filePath.endsWith(SCHEMA_EXTENSION)) {
                    await regenerateTypes(filePath);
                }
            });
        },
    };

    async function regenerateTypes(schemaPath: string) {
        try {
            const schemas = parseSchemaFile(schemaPath);
            if (schemas.length > 0) {
                const dtsContent = generateDts(schemas);
                const dtsPath = schemaPath.replace(/\.tsx$/, '.d.ts');
                fs.writeFileSync(dtsPath, dtsContent);
                // Log only in development when there's an actual change
                console.log(`[schema-types] Regenerated: ${path.basename(dtsPath)}`);
            }
        } catch (error) {
            console.error(`[schema-types] Error processing ${schemaPath}:`, error);
        }
    }
}
```

### Phase 3: Integrate into Astro Config

**File:** `astro.config.mjs`

```javascript
import { schemaTypesPlugin } from './src/lib/vite-plugin-schema-types.ts';

export default defineConfig({
    vite: {
        plugins: [
            tailwindcss(),
            componentScannerPlugin(),
            schemaTypesPlugin(),  // Add new plugin
        ],
        // ...
    },
});
```

### Phase 4: Handle .gitignore Configuration

**Goal:** Make generated `.d.ts` files optionally ignorable.

#### Option 4A: Developer Local Configuration

Add a `.gitignore` entry that developers can uncomment locally:

```gitignore
# Uncomment if you want to ignore auto-generated schema types
# src/**/*.schema.d.ts
```

#### Option 4B: Environment Variable Control

Create a configuration option in `capsulo.config.ts`:

```typescript
export default {
    dev: {
        autoGenerateSchemaTypes: true,
        gitignoreGeneratedTypes: false, // personal preference
    },
    // ...
};
```

#### Option 4C: Local Override File (Recommended)

Create `.gitignore.local` pattern or use Git's `exclude` mechanism:

```bash
# In .git/info/exclude (not tracked)
src/**/*.schema.d.ts
```

Document this approach in `scripts/README.md`.

### Phase 5: Update Documentation

Update `scripts/README.md` with:

1. Auto-generation behavior in dev mode
2. How to disable if needed
3. How to use `.git/info/exclude` for local-only gitignore
4. Manual regeneration still available for CI/builds

---

## Edge Cases and Considerations

### 1. Race Conditions

If a developer rapidly edits a schema file, multiple regenerations could occur. The implementation should:

- Debounce regeneration (e.g., 100ms delay)
- Track in-progress operations to avoid conflicts

### 2. Build-Time Behavior

During `npm run build`:

- The plugin should **not** regenerate types automatically
- Types should already be generated and committed (or run prebuild script)
- Consider adding to `prebuild.js`: schema validation/regeneration

### 3. Initial Dev Start

When starting dev mode:

- Run a full schema scan once at startup
- Regenerate any stale `.d.ts` files

### 4. Deletion Handling

If a `.schema.tsx` file is deleted:

- Should the corresponding `.d.ts` be deleted?
- Recommendation: Yes, add `unlink` handler to watcher

### 5. Error Handling

If a schema file has syntax errors:

- Log clear error message with file path
- Do not overwrite the existing `.d.ts` (preserve last good state)
- Continue watching for fixes

---

## Configuration Options Summary

| Option | Default | Description |
|--------|---------|-------------|
| `enabled` | `true` (dev only) | Enable/disable auto-generation |
| `debounceMs` | `100` | Milliseconds to wait before regenerating |
| `logChanges` | `true` | Log when types are regenerated |
| `deleteOrphaned` | `false` | Delete `.d.ts` when `.schema.tsx` is deleted |

---

## Migration Path

### Step 1: Implement Core Changes

1. Extract shared parser module
2. Create Vite plugin
3. Update astro.config.mjs

### Step 2: Verify Existing Behavior

1. Ensure `generate-schema-types.ts` still works standalone
2. Test dev mode auto-regeneration
3. Verify build process is unaffected

### Step 3: Documentation & Communication

1. Update scripts README
2. Add inline comments to astro.config.mjs
3. Document gitignore options

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Type generation breaks during dev | Low | Medium | Fallback to manual script |
| Performance impact on dev server | Low | Low | Debouncing, async operations |
| Git conflicts from generated files | Medium | Low | Document .git/info/exclude |
| Stale types in production build | Low | High | Add prebuild check |

---

## Alternatives Considered

### 1. Use `tsc --watch`

TypeScript's built-in watch could be extended, but it doesn't understand the custom schema DSL.

### 2. IDE Plugin (VS Code Extension)

Could provide auto-generation on save, but would require extension installation and doesn't integrate with the build process.

### 3. Pre-commit Hook

Run generation before commit. This ensures types are always fresh but doesn't help during active development.

---

## Files to Create/Modify

| File | Action | Purpose |
|------|--------|---------|
| `scripts/lib/schema-parser.ts` | Create | Shared parsing logic |
| `scripts/generate-schema-types.ts` | Modify | Import from shared module |
| `src/lib/vite-plugin-schema-types.ts` | Create | Dev mode watcher |
| `astro.config.mjs` | Modify | Add new plugin |
| `scripts/README.md` | Modify | Document new behavior |
| `.gitignore` | Modify | Add commented-out option |


---

## Success Criteria

1. ✅ Schema changes trigger automatic type regeneration in dev mode
2. ✅ No manual intervention required during development
3. ✅ Build process remains unaffected
4. ✅ Developers can optionally gitignore generated types locally
5. ✅ Clear logging shows when types are regenerated
6. ✅ Error in schema file does not crash dev server

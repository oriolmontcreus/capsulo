# Scripts

This directory contains utility scripts for the Capsulo CMS project.

---

## sync-env.js

### Overview

The `sync-env.js` script automatically syncs GitHub OAuth secrets from the root `.env` file to the worker's `.dev.vars` file. This eliminates the need to manually maintain secrets in multiple locations.

### Purpose

This script is part of the **Configuration Consolidation** strategy that establishes the root `.env` file as the single source of truth for all local development configuration.

### How It Works

1. Reads the root `.env` file
2. Extracts `GITHUB_CLIENT_ID` and `GITHUB_CLIENT_SECRET`
3. Writes them to `workers/github-oauth/.dev.vars`

### Usage

```bash
# Run manually
npm run sync:env

# Automatically runs before dev server
npm run dev
```

### Output Examples

**Successful sync:**
```
üîÑ Syncing environment variables...

‚úÖ Synced 2 secret(s) to workers/github-oauth/.dev.vars
```

**Missing secrets:**
```
üîÑ Syncing environment variables...

‚ö†Ô∏è  Missing or placeholder secrets in .env:
   - GITHUB_CLIENT_ID
   - GITHUB_CLIENT_SECRET

   The OAuth worker may not work correctly without these.
   Get them from your GitHub App settings.

‚ÑπÔ∏è  No secrets to sync (all values are missing or placeholders).
```

---

# Schema Type Generation Script

## Overview

The `generate-schema-types.ts` script is an automated TypeScript code generation tool that scans your project for CMS schema definitions and generates corresponding TypeScript type definitions. It also automatically updates Astro components to use these types, providing end-to-end type safety for your CMS content.

## Purpose

This script solves the problem of maintaining type safety between your CMS schema definitions and the components that consume them. Instead of manually writing TypeScript interfaces for each schema, this tool:

1. **Parses** `.schema.tsx` files to extract field definitions
2. **Generates** `.d.ts` files with TypeScript interfaces
3. **Updates** corresponding `.astro` components with proper type imports and usage

## How It Works

### 1. Schema Discovery

The script recursively scans the `src/` directory for files ending with `.schema.tsx`:

```typescript
const SCHEMA_EXTENSION = '.schema.tsx';
```

### 2. Schema Parsing

It uses the TypeScript Compiler API to parse schema files and supports two patterns:

**Pattern 1: Direct Array Literal**
```typescript
export const HeroSchema = [
  Input('title').required(),
  Textarea('description'),
  // ...
];
```

**Pattern 2: createSchema Function**
```typescript
export const HeroSchema = createSchema('Hero', [
  Input('title').required(),
  Textarea('description'),
  // ...
]);
```

### 3. Field Type Detection

The script analyzes field definitions and maps them to TypeScript types:

| Field Type | TypeScript Type |
|------------|----------------|
| `Input`, `Textarea`, `RichEditor`, `ColorPicker`, `Select`, `FileUpload` | `string` |
| `Switch` | `boolean` |
| `DateField` | `Date` |
| `Repeater` | `T[]` (array of nested interface) |
| Others | `any` |

### 4. Modifier Detection

The parser recognizes field modifiers that affect type optionality:

- **`.required()`** - Makes field non-optional (no `?`)
- **`.defaultValue()`** - Makes field non-optional (guaranteed to have a value)
- **`.itemName('Name')`** - For Repeaters, defines the nested interface name

### 5. Nested Schema Support

For `Repeater` fields with `.itemName()`, the script generates separate interfaces:

**Input Schema:**
```typescript
Repeater('cards', [
  Input('title'),
  Input('description')
]).itemName('Card')
```

**Generated Types:**
```typescript
export interface CardData {
  title?: string;
  description?: string;
}

export interface HeroSchemaData {
  cards: CardData[];
}
```

### 6. Type Generation

For each schema, the script generates a TypeScript interface:

- **Naming Convention**: `{SchemaName}Data`
  - `HeroSchema` ‚Üí `HeroSchemaData`
  - `Card` (Repeater item) ‚Üí `CardData`

- **Field Optionality**: Fields are optional (`?`) unless they have `.required()` or `.defaultValue()`

**Example Output:**
```typescript
// Auto-generated by scripts/generate-schema-types.ts

export interface HeroSchemaData {
  title: string;           // required
  description?: string;    // optional
  cards: CardData[];       // repeater with itemName
}

export interface CardData {
  title?: string;
  description?: string;
}
```

### 7. Astro Component Updates

The script automatically updates corresponding `.astro` files with:

#### a. Type Imports
Adds or updates the type import statement:
```typescript
import type { HeroSchemaData, CardData } from './hero.schema.d';
```

#### b. Props Interface Extension
Updates the `Props` interface to extend the generated type:
```typescript
export interface Props extends HeroSchemaData {}
```

#### c. Generic Type Parameters
Adds generic type parameters to CMS helper functions:
```typescript
// Before
const props = getCMSPropsWithDefaults(import.meta.url, Astro.props);

// After
const props = getCMSPropsWithDefaults<HeroSchemaData>(import.meta.url, Astro.props);
```

#### d. Type Inference in Maps
Removes explicit `: any` annotations to enable TypeScript inference:
```typescript
// Before
props.cards.map((card: any) => ...)

// After
props.cards.map((card) => ...)  // TypeScript infers CardData
```

## Usage

### Running the Script

```bash
# Run directly with tsx
npx tsx scripts/generate-schema-types.ts

# Or add to package.json scripts
npm run generate-types
```

### Typical Workflow

1. Create or modify a `.schema.tsx` file
2. Run the generation script
3. The script will:
   - Generate/update the `.d.ts` file
   - Update the corresponding `.astro` component
   - Log all changes to the console

### Example Output

```
Scanning for schemas...
Parsing hero.schema.tsx...
Found direct array schema: HeroSchema
Generated /path/to/hero.schema.d.ts
Updated Astro component for: Hero.astro
```

## Architecture

### Key Functions

#### `parseSchemaFile(filePath: string): SchemaDefinition[]`
Parses a schema file and returns all schema definitions found (including nested Repeater schemas).

#### `parseFields(arrayLiteral: ts.ArrayLiteralExpression): FieldDefinition[]`
Extracts field definitions from an array literal expression.

#### `parseFieldCall(callExpr: ts.CallExpression, fields: FieldDefinition[])`
Analyzes a field call expression, walking the method chain to extract:
- Root field type (Input, Repeater, etc.)
- Field name
- Modifiers (required, defaultValue, itemName, etc.)
- Nested fields (for Tabs, Grid, Repeater)

#### `getFieldType(typeFn: string): string`
Maps field function names to TypeScript types.

#### `generateDts(schemas: SchemaDefinition[]): string`
Generates the `.d.ts` file content from schema definitions.

#### `replaceGenericCall(...): { content: string; modified: boolean }`
Helper function for updating function calls with generic type parameters. Handles:
- Skipping already-correct generics
- Avoiding false matches with `skipPattern`
- Building updated content efficiently

#### `updateAstroComponent(...)`
Updates the corresponding Astro component file with:
- Type imports
- Props interface extension
- Generic type parameters
- Type inference improvements

#### `main()`
Entry point that orchestrates the entire process:
1. Walks the `src/` directory
2. Finds `.schema.tsx` files
3. Parses each schema
4. Generates types
5. Updates components

## Supported Features

### Field Types
- ‚úÖ Input, Textarea, RichEditor
- ‚úÖ ColorPicker, Select, FileUpload
- ‚úÖ Switch (boolean)
- ‚úÖ DateField (Date)
- ‚úÖ Repeater (with nested types)

### Modifiers
- ‚úÖ `.required()` - Makes field non-optional
- ‚úÖ `.defaultValue()` - Makes field non-optional
- ‚úÖ `.itemName()` - Names Repeater item interface
- ‚úÖ `.tab()` - Extracts fields from tabs
- ‚úÖ `.contains()` - Extracts fields from grids

### Layout Components
- ‚úÖ Tabs - Fields are extracted from tab arrays
- ‚úÖ Grid - Fields are extracted from contains arrays

## Limitations

- Only processes files with `.schema.tsx` extension
- Assumes schema variable names end with `Schema` or use `createSchema()`
- Astro component must have the same base name as the schema (e.g., `HeroSchema` ‚Üí `Hero.astro`)
- Limited to 50 depth levels when parsing method chains (prevents infinite loops)

## Error Handling

The script includes error handling for:
- Missing directories
- Parse errors (logged with context)
- Missing Astro components (silently skipped)

Errors are logged to console but don't stop the entire process, allowing partial success.

## Best Practices

1. **Naming Convention**: Use `{Name}Schema` for schema variables
2. **File Organization**: Keep `.schema.tsx` files in the same directory as corresponding `.astro` components
3. **Repeater Items**: Always use `.itemName()` for type-safe Repeaters
4. **Required Fields**: Use `.required()` or `.defaultValue()` to ensure fields are always present
5. **Re-run After Changes**: Run the script after any schema modifications

## Integration with Development Workflow

Consider adding this script to your development workflow:

```json
{
  "scripts": {
    "dev": "npm run generate-types && astro dev",
    "build": "npm run generate-types && astro build",
    "generate-types": "tsx scripts/generate-schema-types.ts"
  }
}
```

This ensures types are always up-to-date before running or building your application.

## Troubleshooting

### Types not updating?
- Ensure the schema file ends with `.schema.tsx`
- Check that the schema variable name ends with `Schema`
- Verify the Astro component has a matching name

### Wrong types generated?
- Check field type mappings in `getFieldType()`
- Ensure modifiers (`.required()`, etc.) are properly chained
- Look for console errors during parsing

### Astro component not updated?
- Verify the component exists in the same directory
- Check that the component name matches the schema base name
- Ensure the component has an `export interface Props` declaration

## Future Enhancements

Potential improvements for this script:

- Support for more field types
- Custom type mappings configuration
- Watch mode for automatic regeneration
- Validation of generated types against actual usage
- Support for schema composition/inheritance

# Form Validation Implementation

## Overview
Form validation has been implemented in the CMS using Zod schemas to ensure data quality. The validation is **lazy** - it only runs when the user attempts to save, not on every keystroke. This optimizes performance while still catching errors before data is persisted.

## How It Works

### 1. Validation Trigger
- Validation **only runs when the Save button is clicked**
- No live validation while typing (better performance)
- Errors are shown after attempting to save with invalid data

### 2. Validation Flow
```
User clicks "Save changes" button
    ↓
CMSManager.handleSaveAllComponents()
    ↓
Validates all components using Zod schemas (via fieldToZod)
    ↓
If errors found:
  - Store errors in validationErrors state
  - Show error messages inline on fields
  - Throw error to prevent save
  - SaveButton displays error in UI
    ↓
If no errors:
  - Clear any previous validation errors
  - Clean empty values (empty strings → undefined)
  - Save data via storage adapter
  - Update page data state
```

### 3. Components Updated

#### **CMSManager** (`src/components/admin/CMSManager.tsx`)
- Added `validationErrors` state: `Record<componentId, Record<fieldName, errorMessage>>`
- Validates all components in `handleSaveAllComponents()` before saving
- Uses `flattenFields()` to extract only data fields (layouts are not validated)
- Uses `fieldToZod()` to generate Zod schemas for each field
- Passes validation errors down to each `InlineComponentForm`
- Displays validation error alert banner at the top when errors exist
- Throws error to prevent save when validation fails

#### **InlineComponentForm** (`src/components/admin/InlineComponentForm.tsx`)
- Receives `validationErrors` prop from parent CMSManager
- Passes errors to `FieldRenderer` for individual fields via `error` prop
- Passes all errors to layouts via `fieldErrors` prop (for nested fields)
- No live validation - only displays errors when provided after save attempt
- Initializes form data from component data and field defaults

#### **DynamicForm** (`src/components/admin/DynamicForm.tsx`)
- Used when adding new components to a page
- Validates on form submit using `fieldToZod()`
- Uses `attemptedSubmit` flag to only show errors after submit attempt
- Shows errors inline after submit attempt
- Prevents save until all errors are fixed
- Flattens nested layout fields using `flattenFields()`

### 4. Field Validation Rules

All validation rules are defined in Zod schemas generated by `fieldToZod()` from field definitions:

**Input Fields:**
- Email validation for `.type('email')` - validates email format
- URL validation for `.type('url')` - validates URL format
- Number validation for `.type('number')` - validates numeric values
- Required field validation via `.required()`
- Custom validation messages in Zod schemas

**Textarea Fields:**
- `.maxLength(n)` - validates maximum character length
- `.required()` - ensures field is not empty
- String validation (cannot be empty if required)

**Select Fields:**
- Option validation - value must be from defined `.options()` array
- Multiple selection validation for `.multiple()` fields
- `.required()` - ensures a selection is made

## Example Usage

```typescript
// In a schema (e.g., src/lib/form-builder/schemas/contact.schema.tsx):
import { Input, Textarea } from '../fields';
import { createSchema } from '../builders/SchemaBuilder';

export const ContactSchema = createSchema(
  'Contact Form',
  [
    Input('email')
      .label('Contact email')
      .type('email')         // Validates email format via Zod
      .required()            // Makes field required
      .placeholder('contact@example.com'),
    
    Textarea('message')
      .label('Message')
      .maxLength(500)        // Validates max 500 characters
      .required(),
  ],
  'Contact form with validation',
  'contact-form'
);
```

When user enters invalid data and clicks "Save changes":
1. Validation runs on all components
2. Error appears below the invalid field: "Invalid email"
3. Alert banner appears at top: "Please fix the validation errors before saving."
4. Save is prevented (error thrown)
5. Field shows visual error state (red border, error text)

## Performance Benefits

**Before (live validation):**
- Validated on every keystroke
- Multiple Zod schema checks per second
- Could impact performance with many fields

**After (lazy validation):**
- Only validates when user clicks save
- Single validation pass per save attempt
- Much better performance, especially with complex schemas

## User Experience

1. User fills out form fields in CMS
2. No validation errors shown while typing (clean, uninterrupted experience)
3. User clicks "Save changes" button
4. If errors exist:
   - Validation runs on all components
   - Errors appear inline below invalid fields (red text)
   - Alert banner appears at top: "Please fix the validation errors before saving."
   - Fields with errors show red border
   - Save is prevented
   - User fixes errors
   - Clicks "Save changes" again
5. If no errors:
   - Data saves successfully via storage adapter
   - Any previous errors are cleared
   - Success message appears
   - Page data updates

## Technical Details

### Validation Logic
```typescript
// In CMSManager.tsx - handleSaveAllComponents()
const errors: Record<string, Record<string, string>> = {};
let hasAnyErrors = false;

// Only validate components that aren't deleted
pageData.components
  .filter(component => !deletedComponentIds.has(component.id))
  .forEach(component => {
    const schema = availableSchemas.find(s => s.name === component.schemaName);
    if (!schema) return;

    const formData = componentFormData[component.id] || {};
    const componentErrors: Record<string, string> = {};

    // Only validate data fields, not layouts (Grid, Tabs, etc.)
    const dataFields = flattenFields(schema.fields);

    dataFields.forEach(field => {
      const zodSchema = fieldToZod(field);
      const value = formData[field.name] ?? component.data[field.name]?.value;
      const result = zodSchema.safeParse(value);

      if (!result.success) {
        const errorMessage = result.error.errors[0]?.message || 'Invalid value';
        componentErrors[field.name] = errorMessage;
        hasAnyErrors = true;
      }
    });

    if (Object.keys(componentErrors).length > 0) {
      errors[component.id] = componentErrors;
    }
  });

// If there are errors, show them and prevent save
if (hasAnyErrors) {
  setValidationErrors(errors);
  throw new Error('Validation failed. Please fix the errors before saving.');
}

// Clear any previous errors
setValidationErrors({});
```

### Error Display
```tsx
// In InlineComponentForm.tsx
{fields.map((field, index) => {
  // Handle layouts (Grid, Tabs) - pass all errors via fieldErrors
  if (field.type === 'grid' || field.type === 'tabs') {
    const nestedDataFields = flattenFields([field]);
    const layoutValue: Record<string, any> = {};
    nestedDataFields.forEach(dataField => {
      layoutValue[dataField.name] = formData[dataField.name];
    });

    return (
      <FieldRenderer
        key={`layout-${index}`}
        field={field}
        value={layoutValue}
        onChange={handleLayoutChange}
        error={undefined}
        fieldErrors={validationErrors}  // Pass all errors for nested fields
      />
    );
  }

  // Handle data fields - pass individual error
  if ('name' in field) {
    return (
      <FieldRenderer
        key={field.name}
        field={field}
        value={formData[field.name]}
        onChange={(value: any) => handleChange(field.name, value)}
        error={validationErrors?.[field.name]}  // Pass specific error
      />
    );
  }

  return null;
})}
```

## Key Implementation Details

### Field Flattening
- Uses `flattenFields()` to extract only data fields from schemas
- Layouts (Grid, Tabs) are skipped during validation
- Only fields with `name` property are validated
- Nested fields within layouts are flattened and validated individually

### Error Propagation
- Errors stored in `validationErrors` state: `Record<componentId, Record<fieldName, errorMessage>>`
- Passed to `InlineComponentForm` as prop
- Data fields receive `error` prop with specific error message
- Layouts receive `fieldErrors` prop with all errors for nested fields

### Value Cleaning
After validation passes, empty values are cleaned:
```typescript
const cleanValue = (value: any): any => {
  if (value === '' || value === null) {
    return undefined;
  }
  if (Array.isArray(value)) {
    return value.filter(v => v !== '' && v !== null);
  }
  return value;
};
```

## Future Enhancements

Potential improvements:
- [ ] Optional live validation toggle in settings
- [ ] Custom error messages per field in schemas
- [ ] Cross-field validation (e.g., "end date must be after start date")
- [ ] Async validation (e.g., check if email already exists via API)
- [ ] Warning-level validations (non-blocking, informational)
- [ ] Validation on blur (field-level lazy validation)
- [ ] Scroll to first error on validation failure
- [ ] Summary of all errors in validation alert
